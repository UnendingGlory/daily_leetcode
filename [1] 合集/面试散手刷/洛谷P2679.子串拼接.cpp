#include <stdio.h>
#include <cstring>

// 有两个仅包含小写英文字母的字符串 A 和 B。
// 现在要从字符串 A 中取出 k 个互不重叠的非空子串，然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一个新的字符串。
// 请问有多少种方案可以使得这个新串与字符串 B 相等？
// 注意：子串取出的位置不同也认为是不同的方案。

// 输入格式
// 第一行是三个正整数 n, m, k，分别表示字符串 A 的长度，字符串 B 的长度，以及问题描述中所提到的 k，每两个整数之间用一个空格隔开。
// 第二行包含一个长度为 n 的字符串，表示字符串 A。
// 第三行包含一个长度为 m 的字符串，表示字符串 B。
// 1 <= n <= 1000, 1 <= m <= 200, 1 <= k <= m
// 由于答案可能很大，所以这里要求输出答案对 10000000071000000007 取模的结果。

// 输入        输出
// 6 3 1       2
// aabaab 
// aab

// 输入        输出
// 6 3 2       7
// aabaab 
// aab

// Solution: 暴力肯定是不合理的，三维 DP动态规划。
// 首先考虑设计状态。为了保证无后效性的一位一位往后推，我们需要记录：
// 1. i，记录推到 A串的哪一个位置，即 A的前 i个字符。
// 2. j，记录匹配 B串的哪几个字符，由于按照原串顺序，相当于是匹配 B的前 j个字符。
// 3. p，记录划分了几个子串, p <= k。
// 4. v，放了方便转移，标记 0 / 1，即 A的第 i个字符是否选入。
//    如果选入，可能拼接到前面的子串，那么 i - 1个字符必须选入，p不变
//            也可以单独成为一个子串，那么 i - 1个字符可选可不选，p需要增加 1。
// 以 f(i, j, p, v) 代表字符串 A的前 i位为止使用 p个字符串匹配和字符串 B的前 j位，
// 且第 i个位置选或不选 (v)的方案数。
// 状态转移方程：
// A[i] = B[j]时,
// 1. f(i, j, p, 0)，即第 i位不选，那么就是前一位选和不选方案数之和。
//    即 f(i, j, p, 0) = f(i - 1, j, p, 0) + f(i - 1, j, p, 1)
// 2. f(i, j, p, 1)，即第 i位选择，那么有如下几种情况。
//    ① A[i]拼接到前面的子串, i - 1位必须选择，且p不变，即 f(i - 1, j - 1, p, 1)，。
//    ② A[i]单独成为一个子串，i - 1位可选可不选，p增 1。
//      f(i - 1, j - 1, p - 1, 0) + f(i - 1, j - 1, p - 1, 1)
//    综合即 f(i, j, p, 1) = f(i - 1, j - 1, p, 1) + f(i - 1, j - 1, p - 1, 0) + f(i - 1, j - 1, p - 1, 1)
// A[i - 1] != B[j - 1]时，
// 1. f(i, j, p, 0) = f(i - 1, j, p, 0) + f(i - 1, j, p, 1)。
// 2. f(i, j, p, 1)，由于 A[i] != B[j]，所以 f(i, j, p, 1) = 0
// 边界条件：B串为空且 k是0时，无论 A串多长，结果均为1。
//         f(i, 0, 0, 0) = 1，其余皆为 0。
// 最后结果即 f(n, m, k, 0) + f(n, m, k, 1)
// 记得要取余，余数分配律：
// (a + b) % c = (a % c + b % c) % c
// (a + b + c) % d = ((a + b) % c + d % c) % c = ((a + b) % c + d) % c
int solution(int n, int m, int k, char A[], char B[]) {
    const int mod = 1e9 + 7;
    int dp[n + 1][m + 1][k + 1][2];
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i <= n; ++i) {
        dp[i][0][0][0] = 1;
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            for (int p = 1; p <= k; ++p) {
                if (A[i] == B[j]) {
                    dp[i][j][p][0] = (dp[i - 1][j][p][0] + dp[i - 1][j][p][1]) % mod;
                    dp[i][j][p][1] = ((dp[i - 1][j - 1][p][1] + dp[i - 1][j - 1][p - 1][0]) % mod \
                                     + dp[i - 1][j - 1][p - 1][1]) % mod;
                } else {
                    dp[i][j][p][0] = (dp[i - 1][j][p][0] + dp[i - 1][j][p][1]) % mod;
                    dp[i][j][p][1] = 0;
                }
            }
        }
    }

    return (dp[n][m][k][0] + dp[n][m][k][1]) % mod;
}

// 滚动数组进行空间复杂度优化。
// 上述方法时间复杂度：O(nmk)，最多需要开辟 1000 * 200 * 200 * 2 = 8 * 10^7的整数空间，
// 即 (32 * 10^7) B = 300MB的空间，过大。
// 观察上述状态转移方程，i的状态均由 i - 1转移得来，因此只需要存储
int solution_mem(int n, int m, int k, char A[], char B[]) {
    const int mod = 1e9 + 7;
    int dp[m + 1][k + 1][2];
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i <= n; ++i) {
        [0][0][0] = 1;
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            for (int p = 1; p <= k; ++p) {
                if (A[i] == B[j]) {
                    dp[j][p][0] = (dp[j][p][0] + dp[j][p][1]) % mod;
                    dp[j][p][1] = ((dp[j - 1][p][1] + dp[j - 1][p - 1][0]) % mod \
                                     + dp[j - 1][p - 1][1]) % mod;
                } else {
                    dp[j][p][0] = (dp[j][p][0] + dp[j][p][1]) % mod;
                    dp[j][p][1] = 0;
                }
            }
        }
    }

    return (dp[m][k][0] + dp[m][k][1]) % mod;
}

int main() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);
    char A[1005], B[205];
    // 忽略 0位置，指针从 A+1和 B+1位置开始读入
    scanf("%s%s", A + 1, B + 1);
    int ans = solution_mem(n, m, k, A, B);
    printf("%d\n", ans);
    return 0;
}
