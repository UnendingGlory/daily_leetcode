# 题目
给定一个正整数 n，将其拆分为 k个正整数的和（k >= 2），并使这些整数的乘积最大化。  
返回你可以获得的最大乘积。

> 输入: n = 2  
> 输出: 1  
> 解释: 2 = 1 + 1, 1 × 1 = 1。

> 输入: n = 10  
> 输出: 36  
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

# 解法1：动态规划
对于正整数 $n$，$n \ge2$ 时，可以拆分成至少两个整数的和 $i$和 $j$。  

$i$ 可以选择拆分，也可以选择不拆分。  

每个正整数的最大乘积取决于比它小的最大整数对应的最大乘积。 
## 状态转移
当 $i \ge 2$，假设对该数字拆分出的第一个正整数是 $j (1 \le j < i)$，则有以下两种方案：  
1. 可以选择不继续拆分 $i - j$，那么当前数的乘积即 $j * (i - j)$。
2. 选择继续拆分 $i - j$，那么当前述的最大乘积即 $j * dp[i - j]$ 。 

所以当 $j$固定时，有 $$ dp[i] = max(j *(i-j), j * dp[i - j])$$

$j\in[1, i - 1]$，遍历所有的 $j$来得到对应 $i$的最大值。 
## 边界条件
边界条件：0和 1都不能拆分，因此 dp[0] = dp[1] = 0。  
## 最终结果
从前往后递推，不会存在越界的情况，**dp[n]** 即最后的答案。
## 复杂度分析  
时间复杂度：$O({n^2})$  
空间复杂度：$O({n})$
## 代码
```cpp
#include "header.h"
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        for (int i = 2; i <= n; ++i) {
            int cur_max = 0;
            for (int j = 1; j < i; ++j) {
                cur_max = max(max_ans, max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = cur_max;
        }
        return dp[n];
    }
};
```

# 解法2：数学
* 假设能将数字 $n$拆分为 $a$个小数字，即有 $$ n = n_1 + n_2 + ... + n_a$$
* 本题等价于求解：$$ max(n_1 \times n_2 \times ... \times n_a) $$

## 数学推导：
* 根据算术几何平均不等式，等号当且仅当 $a=b$时成立。
$$\sqrt{n_1 \times n_2} \le \frac{n_1 + n_2}{2}$$
* 推广到一般形式，则有以下公式，等号当且仅当 $n_1 = n_2 = ... n_a$时成立。
$$\sqrt[a]{n_1 \times n_2 \times ...\times n_a} \le \frac{n_1 + n_2 + ..n_a}{a} $$
* 因此有以下推论：
> 推论1：如果拆分的数量 $a$确定，则 **各拆分数字相等时**，乘积最大。
* 设如果将数字拆分为 $a$个 $x$，即有 $n = ax$，则乘积为 $x^a$  
将其转换为关于 $x$的公式，即
$$x^{\frac{n}{x}}=({x^{\frac{1}{x}}})^n$$
* 将问题转化为求 $y={x^{\frac{1}{x}}}$的极大值，因此需要对 $x$进行求导。
$$lny=\frac{1}{x}lnx$$
$$\frac{1}{y}y'=\frac{1-lnx}{x^2}$$
$$y'=\frac{1-lnx}{x^2}\cdot x^{\frac{1}{x}}$$  

取$y'=0$，由于$x > 0, x^{\frac{1}{x}} > 0$, 因此 $1 - lnx = 0 => x = e$  
由于 x只能取整数，所以需要取 $x = 2和 x = 3$进行大小比较。
$$ (2^\frac{1}{2})^6 = 2^3 = 8 $$
$$(3^\frac{1}{3})^6 = 3^2 = 9$$
由此推出推论2。
> 推论2：将数字 $n$ **尽量拆分为多个3**时，乘积最大。
## 拆分规则
1. 最优：3。将数字拆分成多个因子3，余数可能为 0,1,2。
2. 次优：2。若余数为 2，则保留，不再拆分为 1和 1。$2 > 1 \times 1$。
3. 最差：1。若余数为 1，则需要将一个 3拿出，拆分为 $2 \times 2$，因为$2\times2>3\times1$。

## 算法流程
1. 当 $n \le 3$时，按照规则不应该拆分，但是题目要求必须拆分，因此必须拆分一个因子1，返回 n - 1。
2. 当 $n \ge 3$时，$n \ / \ 3 = a, n \ \%\  3 = b$，可以按照规则进行讨论。
* 如果 $b=0$，返回 $3^a$
* 如果 $b=1$，对应规则3，返回 $3^{a-1}\times4$
* 如果 $b=2$，对应规则2，返回 $3^{a-1}\times2$
## 复杂度分析  
时间复杂度：$O({1})$  
空间复杂度：$O({1})$
## 代码
```cpp
#include "header.h"
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int a = n / 3, b = n % 3;
        if (b == 0) {
            return pow(3, a);
        }
        if (b == 1) {
            return 4 * pow(3, a - 1);
        }
        if (b == 2) {
            return 2 * pow(3, a);
        }
        return 0;
    }
};
```

```cpp
// 计算优化
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int a = n / 3, b = n % 3;
        int ans = 1;
        for (int i = 0; i < a - 1; ++i) {
            ans *= 3;
        }
        if (b == 0) {
            return 3 * ans;
        }
        if (b == 1) {
            return 4 * ans;
        }
        if (b == 2) {
            return 6 * ans;
        }
        return 0;
    }
};
```