#include "header.h"

// 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
// 任何左括号 ( 必须有相应的右括号 )。
// 任何右括号 ) 必须有相应的左括号 ( 。
// 左括号 ( 必须在对应的右括号之前 )。
// * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
// 一个空字符串也被视为有效字符串。

// 输入: "()"
// 输出: True
// 输入: "(*)"
// 输出: True
// 输入: "(*))"
// 输出: True
// 输入: "()*)"
// 输出: True

// Solution1: 栈。
// 如果是单纯的括号匹配问题，则只需要一个栈存储左括号即可。
// 如果是带星号的括号匹配问题，则需要两个栈。
// 一个栈用来存储左括号的下标，一个栈用来存储星号的下标。
// 算法步骤：
// 1. 遍历字符串，如果是左括号，下标入左括号栈，如果是 ⭐️，下标入 ⭐️栈。
//    如果是右括号，则优先和左括号栈匹配。
//    如果左括号栈为空，则和 ⭐️栈匹配。
// 2. 遍历完成后，左括号栈和 ⭐️栈均有可能还存在元素，且可能可以相互匹配。
//    匹配左括号栈和 ⭐️栈，前提是左括号在 ⭐️的前面。
// 3. 最终检查左括号栈是否为空即可，如果为空说明可以匹配。
//    ⭐️栈可以不管，因为可以当做空。
// 时间复杂度：O(n)，空间复杂度：O(n)。
class Solution {
public:
    bool checkValidString(string s) {
        stack<int> left, star;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(') {
                left.push(i);
            } else if (s[i] == '*') {
                star.push(i);
            } else { // 右括号
                if (!left.empty()) {
                    left.pop();
                } else if (!star.empty()) {
                    star.pop();
                } else {
                    return false;
                }
            }
        }
        while(!left.empty() && !star.empty()) {
            if (left.top() < star.top()) {
                left.pop();
                star.pop();
            } else {
                break;
            }
        }
        return left.empty(); // 是空返回 true
    }
};

// Solution2: 贪心，可以将空间复杂度降至 O(1)。

// 从左到右遍历字符串，遍历过程中，未匹配的左括号数量可能会出现如下变化：
// 1. 如果遇到左括号，则未匹配的左括号数量加 1；
// 2. 如果遇到右括号，则需要有一个左括号和右括号匹配，因此未匹配的左括号数量减 1；
// 3. 如果遇到星号，由于星号可以看成左括号、右括号或空字符串，因此未匹配的左括号数量可能加 1、减 1或不变。

// 基于上述结论，可以在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，根据遍历到的字符更新最小值和最大值：
// 1. 如果遇到左括号，则将最小值和最大值分别加 1。
// 2. 如果遇到右括号，则将最小值和最大值分别减 1。
// 3. 如果遇到星号，则将最小值减 1，将最大值加 1。
// 任何情况下，未匹配的左括号数量必须非负数，因此最大值变成负数时，说明没有左括号能和右括号匹配，返回 false。
// 当最小值为 0时，不应该将最小值继续减少，以确保最小值非负。
// 遍历结束时，所有的左括号都应和右括号匹配，因此只有最小值为 0时，s才是有效的字符串。
// 时间复杂度：O(n)，空间复杂度：O(1)。
class Solution {
public:
    bool checkValidString(string s) {
        int minCount = 0, maxCount = 0;
        for (char c: s) {
            if (c == '(') {
                minCount++;
                maxCount++;
            } else if (c == ')') {
                minCount = max(0, minCount - 1);
                maxCount--;
                if (maxCount < 0) {
                    return false;
                }
            } else {
                minCount = max(0, minCount - 1);
                maxCount++;
            }
        }
        return minCount == 0;
    }
};
