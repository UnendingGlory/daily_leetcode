你现在手里有一份大小为 $n \times n$ 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。  

请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。  

我们这里说的距离是 **「曼哈顿距离」**（ Manhattan Distance）：  

$(x0, y0)$ 和 $(x1, y1)$ 这两个单元格之间的距离是 $|x0 - x1| + |y0 - y1|$ 。  

# 解法1：暴力 BFS
显然，该问题使用 图 BFS算法最合适。 

从海洋单元格开始 BFS，如果 BFS碰到了陆地单元格，那么由BFS的性质，该单元格就是最近的陆地单元格。 

时间复杂度：$O(n^2 * n^2) = O(n^4)$（会超时）。空间复杂度：$O(n^2) 。
```cpp
class Solution {
public:
    int maxDistance(vector<vector<int>>& grid) {
        
    }
};
```

# 解法2：多源 BFS
开辟一个队列，先将所有的源头单元格入队。每次从队列中取出一个源，进行 BFS。

可以从陆地单元格进行多源 BFS。

由于陆地单元格为1， BFS后，将海洋单元格的位置进行修改，可以避免访问数组的设置。

算法过程如下图所示。

![](../../image/1163.%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90.png)

可以想象成你从每个陆地上派了很多支船去踏上伟大航道，踏遍所有的海洋。每当船到了新的海洋，就会分裂成4条新的船，向新的未知海洋前进（访问过的海洋就不去了）。如果船到达了某个未访问过的海洋，那他们是第一个到这片海洋的。很明显，这么多船最后访问到的海洋，肯定是离陆地最远的海洋。

时间复杂度：$O(n^2) 。空间复杂度：$O(n^2) 。
```cpp
class Solution {
public:
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, -1, 0, 1};
    int maxDistance(vector<vector<int>>& grid) {
        int row = grid.size(), col = grid[0].size();
        queue<pair<int, int>> q;

        // 先将所有的陆地入队
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (grid[i][j] == 1) {
                    q.push({i, j});
                }
            }
        }

        // 从每个陆地开始，一圈圈遍历海洋，最后遍历到的海洋就是离陆地最远的海洋
        int x, y;
        bool hasOcean = false;
        pair<int, int> point = {-1, -1};
        while (!q.empty()) {
            point = q.front();
            q.pop();
            // 将四周的海洋入队
            for (int i = 0; i < 4; ++i) {
                x = point.first + dx[i];
                y = point.second + dy[i];
                if (x < 0 || x >= row || y < 0 || y >= col || grid[x][y] != 0) {
                    continue;
                }
                // 直接修改原数组避免了设置访问数组
                grid[x][y] = grid[point.first][point.second] + 1;
                hasOcean = true;
                q.push({x, y});
            }
        }

        // 没有陆地或者海洋
        if (point == pair<int, int>{-1, -1} || !hasOcean) {
            return -1;
        }
        
        // 返回最后一次遍历到海洋的距离
        return grid[point.first][point.second] - 1;
    }
};
```
# 解法3：多源 Dijkstra
队列优化 Dijkstra模板参考见 [最短路模板](../../图/shortestPathTemplate.md)


# 解法4：多源 SPFA
SPFA 模板参考见 [最短路模板](../../图/shortestPathTemplate.md)