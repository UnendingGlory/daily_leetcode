# arr = [1,2,3] -> arr = [1, 3, 2]。
# arr = [2,3,1] -> arr = [3, 1, 2]。
# 必须 原地 修改，只允许使用额外常数空间。

# 采用就地交换的方式。
# 1. 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，
#    以能够让当前排列变大，从而得到下一个排列。
# 2. 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。
#    当交换完成后，「较大数」右边的数需要按照升序重新排列。
#    这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

# 核心1：左边较小数 和 右边较大数 交换。
# 核心2：较小数尽量靠右，较大数尽可能小。然后较大数右边数 升序重排。

# 以排列 [4,5,2,6,3,1] 为例。
# 1. 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，
#    满足「较小数」尽量靠右，而「较大数」尽可能小。
# 2. 当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，
#    序列变为 [4,5,3,1,2,6]。

# 对于长度为 n 的排列 a。
# 1. 从右往左 查找第一个顺序对(i,i+1)，满足 a[i] < a[i+1]。
#    那么对于 k >= i+1, a[k] >= a[k+1]。
#    即区间 [i+1, n) 必定是降序
# 2. 如果找到了顺序对，那么在区间 [i+1, n) 中从后向前查找第一个元素 j 满足 a[j] > a[i]。
#    这样「较大数」即为 a[j]。
# 3. 交换 a[i] 和 a[j]，[i+1, n)依旧是降序
#    可以自己画柱状图理解
#    所以可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = n - 2
        while i >= 0 and nums[i] >= nums[i+1]:
            i -= 1

        if i >= 0:
            j = n - 1
            while j >= i and nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        
        # 双指针反转
        left, right = i + 1, n - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
        return nums
