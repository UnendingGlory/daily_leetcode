#include "header.h"


// 对于十进制加法 15 + 7 来说，共有三个阶段
// 1. 将诸位相加，不带进制 15 + 07 = 12
// 2. 将诸位相加，得到进制 15 + 07 = 010
// 3. 将上面两个阶段的结果相加，12 + 010 = 22

// 对于二进制 1111 + 0111 加法也有这三个加法，结果也相同
// 1. 将诸位相加，不带进制 1111 + 0111 = 1000
// 2. 将诸位相加，得到进制 1111 + 0111 = 01110
// 3. 将上面两个阶段的结果相加，1000 + 01110 = 10110B = 16 + 4 + 2 = 22

// 那么对于二进制，如何避免使用加法？
// 对于阶段1，可以发现 1 + 0 = 1, 1 + 1 = 0, 0 + 0 = 0, 即位异或运算
// 对于阶段2，只有1 + 1产生进位，结果是10，相当于两位做：位与运算再左移一位
// 对于阶段3，依旧是前两个阶段的重复

// 需要重复阶段1和阶段2的运算，直至进位为0
// 由于计算机中是补码的形式，所以加法减法均适用

class Solution {
public:
    int add(int a, int b) {
        if (b == 0) return a;
        int sum, carry, num1 = a, num2 = b;
        while (num2 != 0) {
            sum = num1 ^ num2;
            // C++中负数不支持左移，先转换成unsigned int
            // 再转换成int
            carry = ((unsigned int)(num1 & num2) << 1);
            num1 = sum;
            num2 = carry;
        }
        return sum;
    }
};

