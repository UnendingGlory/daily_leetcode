#include "header.h"
// 与121题相比，此题多次买卖一支股票，求最大利润。
// 卖出股票后，无法在第二天买入股票。
// dp 动态规划。
// 假设以 dp[i]表示第 i天结束后能获得的最大的利润。
// 那么第i天结束后，一共会有三种状态。
// 1. 手上持有一支股票。
// 2. 手上未持有股票，且处于冷冻期。（即第i天卖出了股票）
// 3. 手上未持有股票，且不处于冷冻期。

// 状态转移分析：剖析第 i天结束后和第 i-1天结束后的数值关系。
// 使用 dp[i][0], dp[i][1], dp[i][2]分别表示这三种状态。
// 1. 对于 dp[i][0]，第 i天手上持有一支股票，可能是在第 i-1天结束后就持有的；
//    也有可能是第 i天买入的，第 i天能够买入说明第 i-1天结束对应状态 3。
//    dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])
// 2. 对于 dp[i][1]，手上未持有股票，且处于冷冻期，即第 i天卖出了股票。
//    dp[i][1] = dp[i-1][0] + prices[i]
// 3. 对于 dp[i][2]，手上未持有股票，且不处于冷冻期，说明和第 i-1天结束后状态一致。
//    dp[i][2] = max(dp[i-1][1], dp[i-1][2])

// 这样即得到了所有的状态转移方程。
// 那么最终第 n-1 天获得的最大利润：max(dp[n-1][0], dp[n-1][1], dp[n-1][2])。
// 而最后一天还持有股票显然是没有未持有股票利润大的，所以实际上是 max(dp[n-1][1], dp[n-1][2])。
// 边界条件：第0天结束时，如果手上持有一只股票，那只能是第0天买入的。
// dp[0][0] = -prices[0]，dp[0][1] = dp[0][2] = 0。

// Solution: 使用3个变量存储上一时刻的状态值即可
// 时间复杂度：O(n)，空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int a = -prices[0], b = 0, c = 0;
        for (int i = 1; i < n; ++i) {
            int x = a, y = b, z = c;
            a = max(x, z - prices[i]);
            b = x + prices[i];
            c = max(y, z);
        }
        return max(b, c);
    }
};